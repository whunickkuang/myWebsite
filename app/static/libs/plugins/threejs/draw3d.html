<!doctype html>
<html lang="en">
<head>
	<title>Hello World (Three.js)</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel=stylesheet href="base.css"/>

</head>
<body>

<script src="Three.js"></script>
<script src="Detector.js"></script>
<!--<script src="js/Stats.js"></script>-->
<script src="OrbitControls.js"></script>
<script src="THREEx.KeyboardState.js"></script>
<script src="THREEx.FullScreen.js"></script>
<script src="THREEx.WindowResize.js"></script>
<script src="jquery-1.10.2.min.js"></script>
<script src="helvetiker_regular.typeface.js"></script>
<script src="helvetiker_bold.typeface.js"></script>
<script src="bitstream_vera_sans_mono_roman.typeface.js"></script>
<!-- jQuery code to display an information button and box when clicked. -->
<!--<script src="js/jquery-1.9.1.js"></script>-->
<!--<script src="js/jquery-ui.js"></script>-->
<!--<link rel=stylesheet href="css/jquery-ui.css" />-->
<!--<link rel=stylesheet href="css/info.css"/>-->
<!--<script src="js/info.js"></script>-->
<!--<div id="infoButton"></div>-->
<!--<div id="infoBox" title="Demo Information">-->
<!--This three.js demo is part of a collection at-->
<!--<a href="http://stemkoski.github.io/Three.js/">http://stemkoski.github.io/Three.js/</a>-->
<!--</div>-->
<!-- ------------------------------------------------------------ -->
<div id="ThreeJS" style="z-index: 1; position: absolute; left:0px; top:0px"></div>

<script>
//    document.domain = "jiaju.com";
//    $(document).ready(function(){
//        $("#ThreeJS").children(":first").css("width":"500");
//        $("#ThreeJS").children(":first").css("width":"500");
//    });
/*
	Three.js "tutorials by example"
	Author: Lee Stemkoski
	Date: July 2013 (three.js v59dev)
 */


//////////
// MAIN //
//////////

// standard global variables
var container, scene, camera, renderer, controls, stats;
var keyboard = new THREEx.KeyboardState();
var clock = new THREE.Clock();
var k = 1.5;
// custom global variables
var cube;

// initialization
init();

// animation loop / game loop
animate();

///////////////
// FUNCTIONS //
///////////////

function init()
{
	///////////
	// SCENE //
	///////////
	scene = new THREE.Scene();


    ////////////
	// CAMERA //
	////////////

	// set the view size in pixels (custom or according to window size)
	// var SCREEN_WIDTH = 400, SCREEN_HEIGHT = 300;
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	// camera attributes
	var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
	// set up camera
	//camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);

    var LEFT = window.innerWidth / -k, RIGHT = window.innerWidth / k, TOP = window.innerHeight / k, BOTTOM = window.innerHeight / -k;
    camera = new THREE.OrthographicCamera( LEFT, RIGHT, TOP, BOTTOM, NEAR, FAR);
	// add the camera to the scene
	scene.add(camera);
	// the camera defaults to position (0,0,0)
	// 	so pull it back (z = 400) and up (y = 100) and set the angle towards the scene origin
	//camera.position.set(-1500,388,0);
	camera.lookAt(scene.position);

	//////////////
	// RENDERER //
	//////////////

	// create and start the renderer; choose antialias setting.
	if ( Detector.webgl )
		renderer = new THREE.WebGLRenderer( {antialias:true} );
	else
		renderer = new THREE.CanvasRenderer();

	renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);


	// attach div element to variable to contain the renderer
	container = document.getElementById( 'ThreeJS' );

	// attach renderer to the container div
	container.appendChild( renderer.domElement );

	////////////
	// EVENTS //
	////////////

	// automatically resize renderer
	THREEx.WindowResize(renderer, camera);
	// toggle full-screen on given key press
	THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });

	//////////////
	// CONTROLS //
	//////////////

	// move mouse and: left   click to rotate,
	//                 middle click to zoom,
	//                 right  click to pan
	controls = new THREE.OrbitControls( camera, renderer.domElement );

	///////////
	// LIGHT //
	///////////

	// create a light
	var light = new THREE.PointLight(0xffffff);
	light.position.set(0,250,0);
	scene.add(light);
	var ambientLight = new THREE.AmbientLight(0x111111);
	// scene.add(ambientLight);

	//////////////
	// GEOMETRY //
	//////////////

	// most objects displayed are a "mesh":
	//  a collection of points ("geometry") and
	//  a set of surface parameters ("material")


	var cubeGeometry = new THREE.CubeGeometry( 10, 10, 10, 1, 1, 1 );
    var cylinderGeometry_red = new THREE.CylinderGeometry(2, 2, 50, 16);
    //球体
    var sphereGeometry = new THREE.SphereGeometry(4,20,20);
    var lineGeometry = new THREE.Geometry();


    // use a "lambert" material rather than "basic" for realistic lighting.
    //   (don't forget to add (at least one) light!)
    var cubeMaterial = new THREE.MeshBasicMaterial( {color:0xa3e1d4} );
    var cylinderMaterial_red = new THREE.MeshBasicMaterial( {color: 0x1cb392} );
    var sphereMaterial = new THREE.MeshBasicMaterial( {color: 0x065c4b} );
    var lineMaterialThin = new THREE.LineBasicMaterial( {color: 0x565656, linewidth: 3} );

    function drawNode (list){
        var min = list[0][0];
        var max = list[0][0];
        for (i = 0; i<list.length; i++){

            if(list[i][0]>max){
                max = list[i][0];
            }
            if(list[i][0]<min){
                min = list[i][0];
            }
        }
        var k = 1000/(max - min);
        var average = (min + max)/ 2;


        for(i = 0; i<list.length; ++i){
            var getTexture = function () {
                var canvas = document.createElement('canvas');
                canvas.width = 32;
                canvas.height = 32;

                var ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = true;
                // the body
                ctx.translate(0.5, 0.5);
                ctx.font = "10pt Arial";
                ctx.fillText(list[i][3],2,20);
                ctx.fillText(list[i][3],2.5,20.5);
                ctx.fillStyle = "white";
                ctx.strokeStyle = "#000000";//曲线的颜色

                var texture = new THREE.Texture(canvas);
                texture.needsUpdate = true;
                return texture;
            };
            if(i == 0){
                //GP-C-B
                var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set((list[i][0]-average)*k+15, list[i][1], list[i][2]);
                scene.add(sphere);
                //GP-R-B 靠近画布一侧
                var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set((list[i][0]-average)*k+15, list[i][1], list[i][2]+40);
                scene.add(sphere);
                //GP-L-B
                var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set((list[i][0]-average)*k+15, list[i][1], list[i][2]-40);
                scene.add(sphere);
                //GP-D-B
                var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set((list[i][0]-average)*k+15, list[i][1]-60, list[i][2]);
                scene.add(sphere);
                var p1 = new THREE.Vector3((list[i][0]-average)*k+15, list[i][1], list[i][2]-40);
                var p2 = new THREE.Vector3((list[i][0]-average)*k+15, list[i][1], list[i][2]+40);
                lineGeometry.vertices.push(p1);
                lineGeometry.vertices.push(p2);
                var line = new THREE.Line( lineGeometry, lineMaterialThin , THREE.LinePieces );
                scene.add(line);
                var p1 = new THREE.Vector3((list[i][0]-average)*k+15, list[i][1]-60, list[i][2]);
                var p2 = new THREE.Vector3((list[i][0]-average)*k+15, list[i][1], list[i][2]);
                lineGeometry.vertices.push(p1);
                lineGeometry.vertices.push(p2);
                var line = new THREE.Line( lineGeometry, lineMaterialThin , THREE.LinePieces );
                scene.add(line);
            }
            else if(i == list.length-1){
                //GP-C-E
                var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set((list[i][0]-average)*k-15, list[i][1], list[i][2]);
                scene.add(sphere);
                //GP-R-E
                var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set((list[i][0]-average)*k-15, list[i][1], list[i][2]+40);
                scene.add(sphere);
                //GP-L-E
                var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set((list[i][0]-average)*k-15, list[i][1], list[i][2]-40);
                scene.add(sphere);
                //GP-D-E
                var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set((list[i][0]-average)*k-15, list[i][1]-60, list[i][2]);
                scene.add(sphere);
                var p1 = new THREE.Vector3((list[i][0]-average)*k-15, list[i][1], list[i][2]-40);
                var p2 = new THREE.Vector3((list[i][0]-average)*k-15, list[i][1], list[i][2]+40);
                lineGeometry.vertices.push(p1);
                lineGeometry.vertices.push(p2);
                var line = new THREE.Line( lineGeometry, lineMaterialThin , THREE.LinePieces );
                scene.add(line);
                var p1 = new THREE.Vector3((list[i][0]-average)*k-15, list[i][1]-60, list[i][2]);
                var p2 = new THREE.Vector3((list[i][0]-average)*k-15, list[i][1], list[i][2]);
                lineGeometry.vertices.push(p1);
                lineGeometry.vertices.push(p2);
                var line = new THREE.Line( lineGeometry, lineMaterialThin , THREE.LinePieces );
                scene.add(line);
            }
            else{
                //GP-C-B
                var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set((list[i][0]-average)*k+15, list[i][1], list[i][2]);
                scene.add(sphere);
                //GP-C-E
                var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set((list[i][0]-average)*k-15, list[i][1], list[i][2]);
                scene.add(sphere);
                //GP-R-B 靠近画布一侧
                var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set((list[i][0]-average)*k+15, list[i][1], list[i][2]+40);
                scene.add(sphere);
                //GP-L-B
                var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set((list[i][0]-average)*k+15, list[i][1], list[i][2]-40);
                scene.add(sphere);
                //GP-R-E
                var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set((list[i][0]-average)*k-15, list[i][1], list[i][2]+40);
                scene.add(sphere);
                //GP-L-E
                var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set((list[i][0]-average)*k-15, list[i][1], list[i][2]-40);
                scene.add(sphere);
                //GP-D-B
                var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set((list[i][0]-average)*k+15, list[i][1]-60, list[i][2]);
                scene.add(sphere);
                //GP-D-E
                var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set((list[i][0]-average)*k-15, list[i][1]-60, list[i][2]);
                scene.add(sphere);

                var p1 = new THREE.Vector3((list[i][0]-average)*k+15, list[i][1], list[i][2]-40);
                var p2 = new THREE.Vector3((list[i][0]-average)*k+15, list[i][1], list[i][2]+40);
                lineGeometry.vertices.push(p1);
                lineGeometry.vertices.push(p2);
                var line = new THREE.Line( lineGeometry, lineMaterialThin , THREE.LinePieces );
                scene.add(line);
                var p1 = new THREE.Vector3((list[i][0]-average)*k-15, list[i][1], list[i][2]-40);
                var p2 = new THREE.Vector3((list[i][0]-average)*k-15, list[i][1], list[i][2]+40);
                lineGeometry.vertices.push(p1);
                lineGeometry.vertices.push(p2);
                var line = new THREE.Line( lineGeometry, lineMaterialThin , THREE.LinePieces );
                scene.add(line);
                var p1 = new THREE.Vector3((list[i][0]-average)*k-15, list[i][1]-60, list[i][2]);
                var p2 = new THREE.Vector3((list[i][0]-average)*k-15, list[i][1], list[i][2]);
                lineGeometry.vertices.push(p1);
                lineGeometry.vertices.push(p2);
                var line = new THREE.Line( lineGeometry, lineMaterialThin , THREE.LinePieces );
                scene.add(line);
                var p1 = new THREE.Vector3((list[i][0]-average)*k+15, list[i][1]-60, list[i][2]);
                var p2 = new THREE.Vector3((list[i][0]-average)*k+15, list[i][1], list[i][2]);
                lineGeometry.vertices.push(p1);
                lineGeometry.vertices.push(p2);
                var line = new THREE.Line( lineGeometry, lineMaterialThin , THREE.LinePieces );
                scene.add(line);
            }
            var particleGeometry = new THREE.Geometry();
            var particleMaterial = new THREE.ParticleBasicMaterial({size: 400,map: getTexture(),transparent: true,vertexColors :true,color:0xffffff});
            var particle = new THREE.Vector3((list[i][0]-average)*k, list[i][1]+35, list[i][2]);
            particleGeometry.vertices.push(particle);
            var system = new THREE.ParticleSystem(particleGeometry,particleMaterial);
            scene.add(system);

            if(i != (list.length-1)){
                var p1 = new THREE.Vector3((list[i][0]-average)*k, list[i][1], list[i][2]);
                var p2 = new THREE.Vector3((list[i+1][0]-average)*k, list[i+1][1], list[i+1][2]);
                lineGeometry.vertices.push(p1);
                lineGeometry.vertices.push(p2);
                var lineRough = new THREE.Line( lineGeometry, lineMaterialThin , THREE.LinePieces );
                scene.add(lineRough);
            }


            cube = new THREE.Mesh( cubeGeometry, cubeMaterial );
            cube.position.set((list[i][0]-average)*k, list[i][1], list[i][2]);
            scene.add( cube );

            var cylinder = new THREE.Mesh(cylinderGeometry_red, cylinderMaterial_red);
            cylinder.rotation.x = - Math.PI / 2;
            cylinder.position.set((list[i][0]-average)*k, list[i][1], list[i][2]);
            scene.add(cylinder);
            var cylinder = new THREE.Mesh(cylinderGeometry_red, cylinderMaterial_red);
            cylinder.rotation.z = - Math.PI / 2;
            cylinder.position.set((list[i][0]-average)*k, list[i][1], list[i][2]);
            scene.add(cylinder);
            var cylinder = new THREE.Mesh(cylinderGeometry_red, cylinderMaterial_red);
            cylinder.position.set((list[i][0]-average)*k, list[i][1], list[i][2]);
            scene.add(cylinder);

            var p1 = new THREE.Vector3((list[i][0]-average)*k, list[i][1], list[i][2]-60);
            var p2 = new THREE.Vector3((list[i][0]-average)*k, list[i][1], list[i][2]+60);
            lineGeometry.vertices.push(p1);
            lineGeometry.vertices.push(p2);
            var line = new THREE.Line( lineGeometry, lineMaterialThin , THREE.LinePieces );
            scene.add(line);
            var p1 = new THREE.Vector3((list[i][0]-average)*k, list[i][1], list[i][2]-60);
            var p2 = new THREE.Vector3((list[i][0]-average)*k, list[i][1]-60, list[i][2]-60);
            lineGeometry.vertices.push(p1);
            lineGeometry.vertices.push(p2);
            var line = new THREE.Line( lineGeometry, lineMaterialThin , THREE.LinePieces );
            scene.add(line);
            var p1 = new THREE.Vector3((list[i][0]-average)*k, list[i][1], list[i][2]+60);
            var p2 = new THREE.Vector3((list[i][0]-average)*k, list[i][1]-60, list[i][2]+60);
            lineGeometry.vertices.push(p1);
            lineGeometry.vertices.push(p2);
            var line = new THREE.Line( lineGeometry, lineMaterialThin , THREE.LinePieces );
            scene.add(line);
            var p1 = new THREE.Vector3((list[i][0]-average)*k, list[i][1]-60, list[i][2]+60);
            var p2 = new THREE.Vector3((list[i][0]-average)*k, list[i][1]-60, list[i][2]-60);
            lineGeometry.vertices.push(p1);
            lineGeometry.vertices.push(p2);
            var line = new THREE.Line( lineGeometry, lineMaterialThin , THREE.LinePieces );
            scene.add(line);

//            var TextGeometry = new THREE.TextGeometry(list[i][3], params);
//            var plane = THREE.SceneUtils.createMultiMaterialObject(TextGeometry, [meshMaterial]);
//            plane.position.set((list[i][0]-average)*k-13, list[i][1]+30, list[i][2]);
//            scene.add(plane);
//            var particleGeometry = new THREE.TextGeometry(list[i][3], params);
//            var particleMaterial = new THREE.ParticleBasicMaterial({size: 400,vertexColors :true,color:0xffffff});
//            var particle = new THREE.Vector3(1 * 10,2 * 10, 0);
//            particleGeometry.vertices.push(particle);
////        particleGeometry.colors.push(
////                new THREE.Color(Math.random()*ox00ffff)
////        );
//            var system = new THREE.ParticleSystem(particleGeometry,particleMaterial);
//            scene.add(system);

        }
    }
    //drawNode(list);
    function test1(type,list){
        if(type == 1){
            camera.position.set(0,0,1500);
        }
        if(type == 2){
            camera.position.set(0,1500,0);
        }
        if(type == 3){
            camera.position.set(-1500,0,0);
        }
        if(type == 4){
            camera.position.set(-1500,388,0);
        }
        if(type == 5){
            camera.position.set(0,0,1500);
//
        }
//        if(type == 6  ){
//
//        }
        //var display = 1;
        if(type == 6){
            camera.position.set(0,0,1500);
                //alert("aaa");
                var min = list[0][0];
                var max = list[0][0];
                for (i = 0; i<list.length; i++){

                    if(list[i][0]>max){
                        max = list[i][0];
                    }
                    if(list[i][0]<min){
                        min = list[i][0];
                    }
                }
                var k = 1000/(max - min);
                var average = (min + max)/ 2;
            //if(!display){
//                display = 1;, transparent: true, opacity: 1.0
//            }
//            else{
//                display = 0;
//                var cubeMaterial = new THREE.MeshBasicMaterial( {color:0xcdcdcd, transparent: true, opacity: 0.0} );
//            }
//                var cubeMaterial = new THREE.MeshBasicMaterial( {color:0xcdcdcd} );
//                var cubeGeometry = new THREE.CubeGeometry( average*k*2/(list.length-1), 60, 120, 1, 1, 1 );
//                for(i = 0; i<list.length-1; ++i){
//                    cube = new THREE.Mesh( cubeGeometry, cubeMaterial );
//                    cube.position.set((list[i][0]-average)*k+average*k/(list.length-1), list[i][1]-30, list[i][2]);
//                    scene.add( cube );
//                }
                var planeMaterial = new THREE.MeshBasicMaterial( {color:0xcdcdcd} );
                for(i = 0; i<list.length-1; ++i)
                {
                    //上平面
                    var triGeo1 = new THREE.Geometry();
                    triGeo1.vertices = [new THREE.Vector3((list[i][0]-average)*k, list[i][1], -60),
                                        new THREE.Vector3((list[i][0]-average)*k, list[i][1], 60),
                                        new THREE.Vector3((list[i+1][0]-average)*k, list[i+1][1], 60)];
                    triGeo1.faces.push(new THREE.Face3(0, 1, 2));
                    var triangle1 = new THREE.Mesh(triGeo1, planeMaterial);
                    scene.add(triangle1);
                    var triGeo2 = new THREE.Geometry();
                    triGeo2.vertices = [new THREE.Vector3((list[i][0]-average)*k, list[i][1], -60),
                                        new THREE.Vector3((list[i+1][0]-average)*k, list[i+1][1], 60),
                                        new THREE.Vector3((list[i+1][0]-average)*k, list[i+1][1], -60)];
                    triGeo2.faces.push(new THREE.Face3(0, 1, 2));
                    var triangle2 = new THREE.Mesh(triGeo2, planeMaterial);
                    scene.add(triangle2);
                    //下平面
                    var triGeo3 = new THREE.Geometry();
                    triGeo3.vertices = [new THREE.Vector3((list[i][0]-average)*k, list[i][1]-60, -60),
                                        new THREE.Vector3((list[i][0]-average)*k, list[i][1]-60, 60),
                                        new THREE.Vector3((list[i+1][0]-average)*k, list[i+1][1]-60, 60)];
                    triGeo3.faces.push(new THREE.Face3(2, 1, 0));
                    var triangle3 = new THREE.Mesh(triGeo3, planeMaterial);
                    scene.add(triangle3);
                    var triGeo4 = new THREE.Geometry();
                    triGeo4.vertices = [new THREE.Vector3((list[i][0]-average)*k, list[i][1]-60, -60),
                                        new THREE.Vector3((list[i+1][0]-average)*k, list[i+1][1]-60, 60),
                                        new THREE.Vector3((list[i+1][0]-average)*k, list[i+1][1]-60, -60)];
                    triGeo4.faces.push(new THREE.Face3(2, 1, 0));
                    var triangle4 = new THREE.Mesh(triGeo4, planeMaterial);
                    scene.add(triangle4);
                    //左平面
                    var triGeo5 = new THREE.Geometry();
                    triGeo5.vertices = [new THREE.Vector3((list[i][0]-average)*k, list[i][1], 60),
                                        new THREE.Vector3((list[i+1][0]-average)*k, list[i+1][1]-60, 60),
                                        new THREE.Vector3((list[i+1][0]-average)*k, list[i+1][1], 60)];
                    triGeo5.faces.push(new THREE.Face3(0, 1, 2));
                    var triangle5 = new THREE.Mesh(triGeo5, planeMaterial);
                    scene.add(triangle5);
                    var triGeo6 = new THREE.Geometry();
                    triGeo6.vertices = [new THREE.Vector3((list[i][0]-average)*k, list[i][1]-60, 60),
                                        new THREE.Vector3((list[i][0]-average)*k, list[i][1], 60),
                                        new THREE.Vector3((list[i+1][0]-average)*k, list[i+1][1]-60, 60)];
                    triGeo6.faces.push(new THREE.Face3(2, 1, 0));
                    var triangle6 = new THREE.Mesh(triGeo6, planeMaterial);
                    scene.add(triangle6);
                    //右平面
                    var triGeo7 = new THREE.Geometry();
                    triGeo7.vertices = [new THREE.Vector3((list[i][0]-average)*k, list[i][1], -60),
                                        new THREE.Vector3((list[i+1][0]-average)*k, list[i+1][1]-60, -60),
                                        new THREE.Vector3((list[i+1][0]-average)*k, list[i+1][1], -60)];
                    triGeo7.faces.push(new THREE.Face3(2, 1, 0));
                    var triangle7 = new THREE.Mesh(triGeo7, planeMaterial);
                    scene.add(triangle7);
                    var triGeo8 = new THREE.Geometry();
                    triGeo8.vertices = [new THREE.Vector3((list[i][0]-average)*k, list[i][1]-60, -60),
                                        new THREE.Vector3((list[i][0]-average)*k, list[i][1], -60),
                                        new THREE.Vector3((list[i+1][0]-average)*k, list[i+1][1]-60, -60)];
                    triGeo8.faces.push(new THREE.Face3(0, 1, 2));
                    var triangle8 = new THREE.Mesh(triGeo8, planeMaterial);
                    scene.add(triangle8);
                }


        }
    }
    $(document).ready(function(){
        var list = getQueryString("code");
        var type = getQueryString("type");
		list = JSON.parse(list);
        drawNode(list);
        test1(type,list);

    });
    var getQueryString = function(name) {
        var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)","i");
        var r = window.location.search.substr(1).match(reg);
        if (r!=null) return unescape((r[2])); return null;
    }
	/////////
	// SKY //
	/////////

	// recommend either a skybox or fog effect (can't use both at the same time)
	// without one of these, the scene's background color is determined by webpage background

	// make sure the camera's "far" value is large enough so that it will render the skyBox!
	var skyBoxGeometry = new THREE.CubeGeometry( 10000, 10000, 10000 );
	// BackSide: render faces from inside of the cube, instead of from outside (default).
	var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff, side: THREE.BackSide } );
	var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
	scene.add(skyBox);

	// fog must be added to scene before first render
	scene.fog = new THREE.FogExp2( 0xffffff, 0.00025 );
}

function animate()
{
    requestAnimationFrame( animate );
	render();
	update();
}

function update()
{
    var xx = camera.position.x;
    var yy = camera.position.y;
    var zz = camera.position.z;
    if(document.addEventListener){//firefox
        document.addEventListener('DOMMouseScroll',onMouseWheel_fierfox,false);
    }
    document.onmousewheel = function(ev){ onMouseWheel_chrome(ev); };//chrome
    function onMouseWheel_chrome( event ) {
//        if ( scope.enabled === false ) return;
//        if ( scope.userZoom === false ) return;

        var delta = 0;

        if ( event.wheelDelta ) { // WebKit / Opera / Explorer 9

            delta = event.wheelDelta;

        } else if ( event.detail ) { // Firefox

            delta = - event.detail;

        }

        if ( delta > 0 ) {

            if(k>1){
                k=k+0.1;
            }
            else{
                k = k*1.05;
            }
            var LEFT = window.innerWidth / -k, RIGHT = window.innerWidth / k, TOP = window.innerHeight / k, BOTTOM = window.innerHeight / -k, NEAR = 0.1, FAR = 20000;
            camera = new THREE.OrthographicCamera( LEFT, RIGHT, TOP, BOTTOM, NEAR, FAR);
            scene.add(camera);
            // the camera defaults to position (0,0,0)
            // 	so pull it back (z = 400) and up (y = 100) and set the angle towards the scene origin
            camera.position.set(xx,yy,zz);
            camera.lookAt(scene.position);
            controls = new THREE.OrbitControls( camera, renderer.domElement );

        } else {
            if(k>1){
                k=k-0.1;
            }
            else{
                k = k/1.05;
            }

            var LEFT = window.innerWidth / -k, RIGHT = window.innerWidth / k, TOP = window.innerHeight / k, BOTTOM = window.innerHeight / -k, NEAR = 0.1, FAR = 20000;
            camera = new THREE.OrthographicCamera( LEFT, RIGHT, TOP, BOTTOM, NEAR, FAR);
            scene.add(camera);
            // the camera defaults to position (0,0,0)
            // 	so pull it back (z = 400) and up (y = 100) and set the angle towards the scene origin
            camera.position.set(xx,yy,zz);
            camera.lookAt(scene.position);
            controls = new THREE.OrbitControls( camera, renderer.domElement );

        }

    }
    function onMouseWheel_fierfox( event ) {
//        if ( scope.enabled === false ) return;
//        if ( scope.userZoom === false ) return;

        var delta = 0;

        if ( event.wheelDelta ) { // WebKit / Opera / Explorer 9

            delta = event.wheelDelta;

        } else if ( event.detail ) { // Firefox

            delta = - event.detail;

        }

        if ( delta > 0 ) {

            if(k>1){
                k=k+0.001;
            }
            else{
                k = k*1.0005;
            }
            var LEFT = window.innerWidth / -k, RIGHT = window.innerWidth / k, TOP = window.innerHeight / k, BOTTOM = window.innerHeight / -k, NEAR = 0.1, FAR = 20000;
            camera = new THREE.OrthographicCamera( LEFT, RIGHT, TOP, BOTTOM, NEAR, FAR);
            scene.add(camera);
            // the camera defaults to position (0,0,0)
            // 	so pull it back (z = 400) and up (y = 100) and set the angle towards the scene origin
            camera.position.set(xx,yy,zz);
            camera.lookAt(scene.position);
            controls = new THREE.OrbitControls( camera, renderer.domElement );

        } else {
            if(k>1){
                k= k-0.001;
            }
            else{
                k = k/1.0005;
            }

            var LEFT = window.innerWidth / -k, RIGHT = window.innerWidth / k, TOP = window.innerHeight / k, BOTTOM = window.innerHeight / -k, NEAR = 0.1, FAR = 20000;
            camera = new THREE.OrthographicCamera( LEFT, RIGHT, TOP, BOTTOM, NEAR, FAR);
            scene.add(camera);
            // the camera defaults to position (0,0,0)
            // 	so pull it back (z = 400) and up (y = 100) and set the angle towards the scene origin
            camera.position.set(xx,yy,zz);
            camera.lookAt(scene.position);
            controls = new THREE.OrbitControls( camera, renderer.domElement );

        }

    }
	// delta = change in time since last call (in seconds)
	var delta = clock.getDelta();

	// functionality provided by THREEx.KeyboardState.js
	if ( keyboard.pressed("1") )
		document.getElementById('message').innerHTML = ' Have a nice day! - 1';
	if ( keyboard.pressed("2") )
		document.getElementById('message').innerHTML = ' Have a nice day! - 2 ';

	controls.update();
	//stats.update();
}

function render()
{
	renderer.render( scene, camera );
}


</script>

</body>
</html>
